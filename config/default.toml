# Double Pendulum Simulation Configuration
# All angles are in degrees, converted to radians internally

[physics]
gravity = 9.81
length1 = 1.0
length2 = 1.0
mass1 = 1.0
mass2 = 1.0
initial_angle1_deg = 152.2
initial_angle2_deg = 152.0
initial_velocity1 = 0.0
initial_velocity2 = 0.0

[simulation]
pendulum_count = 10000
angle_variation_deg = 0.1      # Spread around initial_angle1
duration_seconds = 11.0        # Physical simulation time
total_frames = 660             # Number of frames to output

# Physics quality controls simulation accuracy via max timestep:
#   low    = max_dt 20ms (~100 steps/period, visible artifacts)
#   medium = max_dt 12ms (~167 steps/period, acceptable quality)
#   high   = max_dt 7ms  (~286 steps/period, gold standard)
#   ultra  = max_dt 3ms  (~667 steps/period, perfect accuracy)
# You can also set max_dt directly (in seconds) to override the preset.
physics_quality = "high"
# max_dt = 0.007              # Uncomment to override quality preset

[render]
width = 1080
height = 1080
thread_count = 16               # 0 = auto-detect hardware concurrency

[post_process]
# Standard post-processing pipeline: normalize -> exposure -> tone_map -> contrast -> gamma
tone_map = "none"              # "none", "reinhard", "reinhard_extended", "aces", "logarithmic"
reinhard_white_point = 1.0     # Only used with reinhard_extended
exposure = 0.0                 # Brightness in stops (0 = no change, +1 = 2x brighter)
contrast = 1.0                 # Centered at 0.5 (1.0 = no change, >1 = more contrast)
gamma = 2.2                    # Display gamma (2.2 = sRGB standard)

[color]
scheme = "spectrum"            # spectrum, rainbow, heat, cool, monochrome
start = 0.0                    # Range start [0, 1]
end = 1.0                      # Range end [0, 1]

[detection]
# EventDetector: real-time chaos detection with ABSOLUTE threshold
chaos_threshold = 500.0        # radians^2 - triggers when variance exceeds this
chaos_confirmation = 10        # Consecutive frames above threshold to confirm

# Optional early stopping
early_stop_after_chaos = false

# ============================================================================
# PREDICTION TARGETS
# ============================================================================
# Configure how boom/chaos frames are detected using FrameDetector (post-hoc).
# Note: EventDetector chaos (above) uses ABSOLUTE threshold for real-time detection.
#       [targets.chaos] uses RELATIVE threshold (0.0-1.0) for post-hoc analysis.
#
# Available methods for frame targets:
#   max_value            - Frame with maximum metric value
#   first_peak_percent   - First peak >= X% of max (peak_percent_threshold)
#   derivative_peak      - When d(metric)/dt is maximum (smoothing_window)
#   second_derivative_peak - When d²(metric)/dt² is maximum (smoothing_window)
#   threshold_crossing   - First sustained crossing of threshold (crossing_*)
#
# Available methods for score targets:
#   peak_clarity   - How distinct the main peak is (0.5=equal peaks, 1.0=single peak)
#   post_boom_area - Normalized area under curve after boom
#   composite      - Weighted combination (not yet implemented)

[targets.boom]
type = "frame"
metric = "cv_causticness"      # Which metric to use for detection
method = "threshold_crossing"  # Detection algorithm
offset_seconds = -0.50         # Offset applied after detection (negative = earlier)
# Method-specific parameters:
peak_percent_threshold = 0.60  # For first_peak_percent
min_peak_prominence = 0.05     # For first_peak_percent
smoothing_window = 5           # For derivative_peak, second_derivative_peak
crossing_threshold = 0.80      # For threshold_crossing (fraction of max)
crossing_confirmation = 1      # For threshold_crossing (consecutive frames)

# Example chaos target (uses relative threshold, different from detection.chaos_threshold)
# [targets.chaos]
# type = "frame"
# metric = "variance"
# method = "threshold_crossing"
# offset_seconds = 0.0
# crossing_threshold = 0.80       # 80% of max variance
# crossing_confirmation = 10

# Example quality score target
# [targets.boom_quality]
# type = "score"
# method = "peak_clarity"
# metric = "cv_causticness"

[filter]
min_boom_seconds = 8.0   # Boom between 8-15 seconds
max_boom_seconds = 15.0
min_uniformity = 0.9     # Minimum distribution uniformity (0=concentrated, 1=uniform on disk)

[output]
format = "png"                 # "png" or "video"
directory = "output"
filename_prefix = "frame"
video_codec = "libx264"
video_crf = 23                 # Quality (0-51, lower = better)
video_fps = 60                 # Video FPS (only affects video encoding, not simulation)
